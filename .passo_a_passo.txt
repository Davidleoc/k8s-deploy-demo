O objetivo:

Criar uma aplicaÃ§Ã£o containerizada, rodar em Kubernetes local (kind), expor via Ingress e automatizar build + deploy usando GitHub Actions com runner self-hosted dentro da rede interna.

1ï¸âƒ£ CriaÃ§Ã£o do repositÃ³rio

Primeiro, foi criado um repositÃ³rio no GitHub chamado:

k8s-deploy-demo


Esse repositÃ³rio passou a ser:

A fonte da verdade do projeto

Onde ficam cÃ³digo, manifests Kubernetes e pipeline CI/CD

2ï¸âƒ£ Estrutura do repositÃ³rio

A estrutura final ficou assim:

k8s-deploy-demo/
â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.go
â”‚   â””â”€â”€ Dockerfile
â”‚
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â”œâ”€â”€ ingress.yaml
â”‚   â””â”€â”€ configmap.yaml
â”‚
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â””â”€â”€ deploy.yaml


ğŸ“Œ Essa separaÃ§Ã£o Ã© fundamental:

app/ â†’ cÃ³digo e imagem Docker

k8s/ â†’ infraestrutura Kubernetes

.github/ â†’ automaÃ§Ã£o CI/CD

3ï¸âƒ£ CriaÃ§Ã£o da aplicaÃ§Ã£o

Foi criada uma aplicaÃ§Ã£o simples em Go:

Escuta na porta 8080

LÃª uma variÃ¡vel de ambiente WELCOME_MSG

Retorna essa mensagem via HTTP

ğŸ‘‰ O objetivo nÃ£o era a aplicaÃ§Ã£o, mas sim aprender Kubernetes e deploy.

4ï¸âƒ£ Dockerfile

Dentro de app/Dockerfile:

FROM golang:1.20-alpine

WORKDIR /app
COPY . .

RUN go build -o server

EXPOSE 8080
CMD ["./server"]

O que acontece aqui:

Usa uma imagem base com Go

Copia o cÃ³digo

Compila o binÃ¡rio

ExpÃµe a porta 8080

Executa o servidor

ğŸ“Œ Esse Dockerfile gera a imagem que o Kubernetes roda.

5ï¸âƒ£ Build da imagem local

No servidor:

docker build -t davidl05/k8s-demo:v1 ./app


Isso criou a imagem:

davidl05/k8s-demo:v1


ğŸ“Œ Essa imagem depois foi usada:

Pelo Kubernetes

Pelo CI/CD

Pelo Docker Hub

6ï¸âƒ£ CriaÃ§Ã£o do cluster Kubernetes (kind)

Foi criado um cluster Kubernetes local usando:

kind create cluster --name k8s-demo


Isso:

Criou um node Kubernetes dentro de um container Docker

Instalou todo o control-plane

Gerou o kubeconfig

7ï¸âƒ£ InstalaÃ§Ã£o do Ingress Controller

O Kubernetes nÃ£o expÃµe HTTP sozinho.

EntÃ£o foi instalado o Ingress NGINX:

kubectl apply -f \
https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml


Isso criou:

Namespace ingress-nginx

Controller escutando portas 80 e 443

8ï¸âƒ£ ConfigMap

Arquivo k8s/configmap.yaml:

apiVersion: v1
kind: ConfigMap
metadata:
  name: demo-config
data:
  welcome_msg: "OlÃ¡ do Kubernetes!"


ğŸ“Œ Serve para:

Separar configuraÃ§Ã£o do cÃ³digo

Injetar variÃ¡veis no container

9ï¸âƒ£ Deployment

Arquivo k8s/deployment.yaml:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: k8s-demo
  template:
    metadata:
      labels:
        app: k8s-demo
    spec:
      containers:
      - name: k8s-demo
        image: davidl05/k8s-demo:v1
        ports:
        - containerPort: 8080
        env:
        - name: WELCOME_MSG
          valueFrom:
            configMapKeyRef:
              name: demo-config
              key: welcome_msg


ğŸ“Œ Isso diz ao Kubernetes:

Quero 3 Pods

Rodando essa imagem

Com essa variÃ¡vel de ambiente

ğŸ”Ÿ Service

Arquivo k8s/service.yaml:

apiVersion: v1
kind: Service
metadata:
  name: demo-service
spec:
  selector:
    app: k8s-demo
  ports:
  - port: 80
    targetPort: 8080


ğŸ“Œ O Service:

Cria um IP fixo interno

Balanceia trÃ¡fego entre os Pods

1ï¸âƒ£1ï¸âƒ£ Ingress

Arquivo k8s/ingress.yaml:

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: demo.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: demo-service
            port:
              number: 80


ğŸ“Œ Isso conecta:

HTTP â†’ Ingress â†’ Service â†’ Pods

1ï¸âƒ£2ï¸âƒ£ AplicaÃ§Ã£o dos manifests
kubectl apply -f k8s/


Depois disso:

Pods ficaram Running

AplicaÃ§Ã£o respondeu via navegador

 PARTE 2 â€” CI/CD EXPLICADO EM PROFUNDIDADE

Agora vem a parte mais importante.

ğŸ¯ Objetivo do CI/CD

Automatizar:

Build da imagem Docker

Push para Docker Hub

Deploy automÃ¡tico no Kubernetes

Tudo isso a cada push na branch main.

1ï¸âƒ£ Por que runner self-hosted?

Seu servidor Kubernetes estÃ¡:

Em rede interna

NÃ£o acessÃ­vel pela internet

ğŸ“Œ Por isso:

NÃ£o Ã© possÃ­vel fazer deploy direto com runners do GitHub

SoluÃ§Ã£o:

Criar um GitHub Actions Runner self-hosted rodando dentro da mesma mÃ¡quina do cluster.

2ï¸âƒ£ CriaÃ§Ã£o do runner

VocÃª:

Baixou o runner oficial do GitHub

Registrou ele no repositÃ³rio

Rodou como usuÃ¡rio github

Esse runner:

Executa os workflows

Tem acesso ao Docker

Tem acesso ao Kubernetes

3ï¸âƒ£ Secrets no GitHub

VocÃª criou os seguintes secrets:

DOCKER_USERNAME
DOCKER_PASSWORD
SERVER_HOST
SERVER_USER
SERVER_PASSWORD


ğŸ“Œ Eles sÃ£o:

Criptografados

NÃ£o aparecem nos logs

Usados pelo workflow

4ï¸âƒ£ Workflow do GitHub Actions

Arquivo .github/workflows/deploy.yaml

name: Build and Deploy

on:
  push:
    branches:
      - main


ğŸ“Œ Toda vez que alguÃ©m dÃ¡ git push na main, o pipeline roda.

Job
jobs:
  build-and-deploy:
    runs-on: self-hosted


ğŸ“Œ Diz:

Execute no runner que eu instalei no meu servidor

Checkout do cÃ³digo
- uses: actions/checkout@v3


Baixa o repositÃ³rio para o runner.

Login no Docker Hub
- uses: docker/login-action@v2


Autentica para poder fazer push da imagem.

Build e push
docker build -t user/k8s-demo:v1 ./app
docker push user/k8s-demo:v1


ğŸ“Œ Isso:

Gera a imagem

Publica no Docker Hub

Deploy no Kubernetes
kubectl set image deployment/demo-deployment \
  k8s-demo=user/k8s-demo:v1


ğŸ“Œ Isso faz:

Atualiza a imagem do Deployment

Kubernetes recria Pods automaticamente

Zero downtime (rolling update)

5ï¸âƒ£ Por que o kubeconfig foi essencial?

O runner usa:

/root/.kube/config


Sem isso:

kubectl nÃ£o sabe onde estÃ¡ o cluster

Erro localhost:8080

VocÃª resolveu isso garantindo:

PermissÃ£o correta

ExecuÃ§Ã£o no usuÃ¡rio certo

O acesso ao localhost:8080 sÃ³ existe enquanto o comando abaixo estÃ¡ rodando:

kubectl port-forward svc/demo-service 8080:80

-- Como aplicar uma mudanÃ§a feita na aplicaÃ§Ã£o pelo repositÃ³rio no servidor

git pull origin main

kubectl apply -f configmap.yaml

kubectl get pods

kubectl delete pod <nome-pod>  # Para recriar o Pod 




